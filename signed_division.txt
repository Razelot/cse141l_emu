/*Loads the MSB of the dividend into
  r5*/
addi 8 0 0 //r8 = 0
tr 1 8
inc 1
inc 1
inc 1
inc 1
inc 1
inc 1
inc 1 //r1 = 7
tr 5 8
inc 5
sll 5 1 //r5 = 128
lw 5 3 //r3 = MSB(dividend)

/*Checks if MSB of dividend is
  negative*/
tr 4 8 //r4 = 0
add 4 3 9 //r9 = MSB(dividend)
tr 6 9
srl 6 1 //r6 = 0/1
tr 2 6 //r2 = 0/1
beq 2 8 //if r2 == 1, make pos

/*beq: r2 == 1. Load LSB of dividend
  into r. NOT it. Add 1.*/
addi 8 0 1 //r8 = 129
tr 3 8 //r3 = 129
lw 7 3 //r7 = LSB(dividend)
not 7 //r7 = ~LSB(dividend)
tr 8 7 //r8 = ~LSB(dividend)
addi 8 0 1 //r8 = ~LSB(dividend)+1

/*beq: r2 == 1. NOT the MSB of dividend.
  Adds 1 if carryover from LSB.

/*beq: r2 == 1. Write M[128] with pos
  value. Write M[1] with neg flag*/

/* beq: r2 == 0.

/*Checks if MSB of divisor is neg*/

/*beq: == 1. NOT the divisor. Add 1.

/*beq: == 1. Write M[130] with pos
  divisor. Write M[2] with neg flag*/

/*beq: == 0.

/*Loop Setup. Clear all registers.*/
halt
