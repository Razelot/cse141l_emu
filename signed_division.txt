/*Loads MSB of dividend*/
addi 8 0 0
tr 1 8
inc 1
inc 1
inc 1
inc 1
inc 1
inc 1
inc 1 //r1 = 7
tr 5 8
inc 5
sll 5 1 //r5 = 128
lw 5 3 //r3 = MSB(dividend)

/*Checks if MSB of dividend is
  negative*/
tr 4 8 //r4 = 0
add 4 3 9 //r9 = MSB(dividend)
tr 6 9
srl 6 1 //r6 = 0/1
tr 2 6 //r2 = 0/1
beq 2 8
jr 2 //if r2 != r8
jr 21 //if r2 == r8

/*beq: MSB is Negative. Load LSB of
  dividend. NOT it. Add 1.*/
tr 8 5
addi 8 0 1
tr 3 8 //r3 = 129
lw 7 3
not 7
tr 8 7
addi 8 0 1 //r8 = ~LSB(dividend)+1
tr 1 12 //r1 = overflow

/*beq: MSB is Negative. NOT MSB of
  dividend. Add carry over from LSB.*/
not 9
tr 7 9 //r7 = ~MSB(dividend)
add 7 1 9 //r9 = ~MSB(dividend)+carry

/*beq: MSB is Negative. Write M[128] and
  M[129] with positive value. Write M[1]
  with negative flag*/
tr 1 9 //r1 = ~MSB(dividend)+carry
sw 5 1 //M[128] = MSB(dividend)
inc 5 //r5 = 129
tr 1 8 //r1 = ~LSB(dividend)+1
sw 5 1 //M[129] = LSB(dividend)
addi 8 0 1 //r8 = 1
tr 7 8 //r7 = 1
tr 2 8 //r2 = 1
sw 7 2 //M[1] = 1

/* beq: r2 == 0. Continues.

/*Loads divisor.*/

/*Checks if divisor is neg*/

/*beq: Divisor is Negative. NOT the
  divisor. Add 1. Store in M[130]. Store
  M[2] with negative flag. */

/*beq: Divisor is Positive. Continue.*/

/*Loop Setup. Clear all registers.*/
halt
